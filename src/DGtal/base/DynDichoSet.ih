/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file DynDichoSet.ih
 * @author Jacques-Olivier Lachaud (\c jacques-olivier.lachaud@univ-savoie.fr )
 * Laboratory of Mathematics (CNRS, UMR 5127), University of Savoie, France
 *
 * @date 2014/04/08
 *
 * Implementation of inline methods defined in DynDichoSet.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

//-----------------------------------------------------------------------------
template <typename T>
inline
DGtal::DynDichoSet<T>::~DynDichoSet()
{
}

//-----------------------------------------------------------------------------
template <typename T>
inline
DGtal::DynDichoSet<T>::DynDichoSet()
  : myData( 2 )
{
  myData.reserve( 128 );
  myNb = 0;
}
//-----------------------------------------------------------------------------
template <typename T>
inline
typename DGtal::DynDichoSet<T>::Size
DGtal::DynDichoSet<T>::size() const
{
  return myNb;
}

//-----------------------------------------------------------------------------
template <typename T>
inline
typename DGtal::DynDichoSet<T>::ConstIterator
DGtal::DynDichoSet<T>::end() const
{
  return myData.end();
}
//-----------------------------------------------------------------------------
template <typename T>
inline
typename DGtal::DynDichoSet<T>::ConstIterator
DGtal::DynDichoSet<T>::find( const T& v ) const
{
#ifdef WITH_OPENMP
  Size k = Bits::mostSignificantBit( myNb );
  std::vector<ConstIterator> v( k+1 );
#pragma omp parallel for schedule(dynamic)
  

  Size j = 1;
  while ( j < myData.size() )
    {
      if ( ( myNb & j ) != 0 )
        {
          ConstIterator it = dichotomy( j, 2*j-1, v );
          if ( it != end() ) return it;
        }
      j <<= 1;
    }
  return end();

#ifdef WITH_OPENMP
      std::vector<DigitalSet::Iterator> v( S.size() );
      std::vector<uint8_t> b( v.size() );
      for ( size_t i = 0; it != itE; ++it, ++i )
	v[ i ] = it;
#pragma omp parallel for schedule(dynamic)
      for ( size_t i = 0; i < v.size(); ++i )
	b[ i ] = shape.isSimple( *(v[ i ]) );

      for ( size_t i = 0; i < v.size(); ++i )
	if ( b[ i ] ) Q.push( v[ i ] ); 
#else

}
//-----------------------------------------------------------------------------
template <typename T>
inline
typename DGtal::DynDichoSet<T>::ConstIterator
DGtal::DynDichoSet<T>::dichotomy( Size i, Size j, const T& v ) const
{
  if ( i == j ) return ( myData[ i ] == v ) ? ( myData.begin() + i ) : end();
  else {
    Size m = (i+j) / 2;
    if ( myData[ m ] < v ) return dichotomy( m+1, j, v );
    else                   return dichotomy( i,   m, v );
  }
}
//-----------------------------------------------------------------------------
template <typename T>
inline
void
DGtal::DynDichoSet<T>::insert( const T& val )
{
  if ( find( val ) != end() ) return;
  if ( ( myNb & 0x1 ) == 0 )
    { // even case -> easy
      myData[ 1 ] = val;
      ++myNb;
    }
  else
    {
      myData[ 0 ] = val;
      Size i = 0; 
      Size j = 1;
      while ( ( myNb & j ) != 0 )
        {
          if ( myNb & (j<<1) ) mergeInplace( j );
          else                 mergeAfter( j );
          ++i; j <<= 1;
        }
      ++myNb;
    }
}
//-----------------------------------------------------------------------------
template <typename T>
inline
void
DGtal::DynDichoSet<T>::mergeInplace( Size j )
{
  // std::inplace_merge( myData.begin(), myData.begin() + j, myData.begin() + 2*j );
  std::vector<T> internal( 2*j );
  ConstIterator in1 = myData.begin();
  ConstIterator in2 = myData.begin() + j;
  ConstIterator en1 = in2;
  ConstIterator en2 = in2 + j;
  Iterator out      = internal.begin();
  while ( ( in1 != en1 ) && ( in2 != en2 ) )
    *out++ = ( *in1 < *in2 ) ? *in1++ : *in2++;
  while ( in1 != en1 ) *out++ = *in1++;
  while ( in2 != en2 ) *out++ = *in2++;
  // copies everything back in place.
  std::copy( internal.begin(), internal.end(), myData.begin() );  
}
//-----------------------------------------------------------------------------
template <typename T>
inline
void
DGtal::DynDichoSet<T>::mergeAfter( Size j )
{
  if ( myData.size() < 4*j ) myData.resize( 4*j );
  ConstIterator in1 = myData.begin();
  ConstIterator in2 = myData.begin() + j;
  ConstIterator en1 = in2;
  ConstIterator en2 = in2 + j;
  Iterator out      = myData.begin() + 2*j;
  while ( ( in1 != en1 ) && ( in2 != en2 ) )
    *out++ = ( *in1 < *in2 ) ? *in1++ : *in2++;
  while ( in1 != en1 ) *out++ = *in1++;
  while ( in2 != en2 ) *out++ = *in2++;
}

///////////////////////////////////////////////////////////////////////////////
// Interface - public :

/**
 * Writes/Displays the object on an output stream.
 * @param out the output stream where the object is written.
 */
template <typename T>
inline
void
DGtal::DynDichoSet<T>::selfDisplay ( std::ostream & out ) const
{
  out << "[DynDichoSet]";
}

/**
 * Checks the validity/consistency of the object.
 * @return 'true' if the object is valid, 'false' otherwise.
 */
template <typename T>
inline
bool
DGtal::DynDichoSet<T>::isValid() const
{
    return true;
}



///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

template <typename T>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
		  const DynDichoSet<T> & object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


