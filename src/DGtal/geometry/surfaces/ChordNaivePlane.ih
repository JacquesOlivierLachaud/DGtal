/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file ChordNaivePlane.ih
 * @author Jacques-Olivier Lachaud (\c jacques-olivier.lachaud@univ-savoie.fr )
 * Laboratory of Mathematics (CNRS, UMR 5127), University of Savoie, France
 * @author Yan GÃ©rard
 * @author Isabelle Debled-Rennesson
 * @author Paul Zimmermann
 *
 * @date 2012/09/20
 *
 * Implementation of inline methods defined in ChordNaivePlane.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
inline
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
~ChordNaivePlane()
{ // Nothing to do.
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
inline
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
ChordNaivePlane()
{ // Object is invalid
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
inline
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
ChordNaivePlane( const ChordNaivePlane & other )
  : z( other.z ), x( other.x ), y( other.y ),
    myWidth0( other.myWidth0 ),
    myWidth1( other.myWidth1 ),
    myPointSet( other.myPointSet ),
    myState( other.myState )
{
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
inline
DGtal::ChordNaivePlane<TPoint, TInternalScalar> &
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
operator=( const ChordNaivePlane & other )
{
  if ( this != &other )
    {
      z = other.z;
      x = other.x;
      y = other.y;
      myWidth0 = other.myWidth0;
      myWidth1 = other.myWidth1;
      myPointSet = other.myPointSet;
      myState = other.myState;
    }
  return *this;
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
inline
void
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
clear()
{
  myPointSet.clear();
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
inline
void
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
init( Dimension axis,
      InternalScalar widthNumerator,
      InternalScalar widthDenominator )
{
  ASSERT( ( 0 <= axis ) && ( axis < 3 ) );
  myWidth0 = widthNumerator;
  myWidth1 = widthDenominator;
  switch ( axis ) {
  case 0: x = 1; y = 2; z = 0; break;
  case 1: x = 2; y = 0; z = 1; break;
  case 2: x = 0; y = 1; z = 2; break;
  }
  clear();
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
inline
typename DGtal::ChordNaivePlane<TPoint, TInternalScalar>::Size
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
size() const
{
  return myPointSet.size();
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
inline
bool
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
empty() const
{
  return myPointSet.empty();
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
inline
typename DGtal::ChordNaivePlane<TPoint, TInternalScalar>::Size
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
max_size() const
{
  return myPointSet.max_size();
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
inline
typename DGtal::ChordNaivePlane<TPoint, TInternalScalar>::Size
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
maxSize() const
{
  return max_size();
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
inline
bool
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
operator()( const Point & p ) const
{
  _d = internalDot( myState.N, p );
  return ( _d >= myState.min ) && ( _d <= myState.max );
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
inline
bool
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
extendAsIs( const Point & p )
{ 
  ASSERT( isValid() );
  if ( empty() ) {
    myPointSet.insert( p );
    return setUp1( p );
  }
  bool ok = this->operator()( p );
  if ( ok ) myPointSet.insert( p );
  return ok;
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
bool
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
extend( const Point & p )
{
  unsigned int loop;
  ASSERT( isValid() );
  // Checks if algorithm is initialized.
  if ( extendAsIs( p ) ) 
    {
      // std::cout << "extended as is: " << p << std::endl;
      return true;
    }
  std::pair<Iterator,bool> ins = myPointSet.insert( p );
  Iterator itP = ins.first;
  ASSERT( ins.second == true );
  if ( myState.nbValid < 3 )
    { // initial case
      _state.nbValid = findTriangle( _state, myPointSet.begin(), myPointSet.end() );
      // std::cout << "findTriangle #=" << _state.nbValid << std::endl;
      setUpNormal( _state );
    }
  else 
    _state = myState;
  unsigned int result = 0; // 0: computing, 1: too large, 2: found.
  for ( loop = 0; result == 0; ++loop )
    {
      computeHeight( _state );
      if ( ( _state.height * myWidth1 ) >= ( _state.N[ z ] * myWidth0 ) ) // because width is strict
        result = 1;
      else
        {
          computeMinMax( _state, myPointSet.begin(), myPointSet.end() );
          if ( checkWidth( _state ) )
            {
              // std::cout << "We recognize a subset of the digital plane of characteristics" << std::endl
              //           << "mu=" << _state.min 
              //           << " [a,b,c]=[" << _state.N[ 0 ] << "," << _state.N[ 1 ] << "," << _state.N[ 2 ] << "]" 
              //           << std::endl;
              result = 2;
            }
          else
            {
              Point M = _state.ptMax - _state.ptMin;
              if ( _state.nbValid < 3 )
                newCurrentSegment( _state, M );
              else
                newCurrentTriangle( _state, M );
              // std::cerr << "(loop=" << loop << ") ";
              // selfDisplay( std::cerr, _state );
              // std::cerr << std::endl;
              computeNormal( _state );
            }
        }
      if (loop>=1000) {
        std::cerr << "[ChordNaivePlane::extend()]"
                  << " more than 1000 loops, computing error suspected" << std::endl;
        result = 1;
      }
    }
  // was unable to find a correct plane.
  if ( result == 2 )
    myState = _state;
  else
    myPointSet.erase( itP );
  return result == 2;
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
bool
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
isExtendable( const Point & p ) const
{
  unsigned int loop;
  ASSERT( isValid() );
  if ( empty() || this->operator()( p ) ) return true;
  std::pair<Iterator,bool> ins = myPointSet.insert( p );
  Iterator itP = ins.first;
  ASSERT( ins.second == true );
  if ( myState.nbValid < 3 )
    { // initial case
      _state.nbValid = findTriangle( _state, myPointSet.begin(), myPointSet.end() );
      // std::cout << "findTriangle #=" << _state.nbValid << std::endl;
      setUpNormal( _state );
    }
  else 
    _state = myState;
  unsigned int result = 0; // 0: computing, 1: too large, 2: found.
  for ( loop = 0; result == 0; ++loop )
    {
      computeHeight( _state );
      if ( ( _state.height * myWidth1 ) >= ( _state.N[ z ] * myWidth0 ) ) // check >= 
        result = 1;
      else
        {
          computeMinMax( _state, myPointSet.begin(), myPointSet.end() );
          if ( checkWidth( _state ) )
            {
              // std::cout << "We recognize a subset of the digital plane of characteristics" << std::endl
              //           << "mu=" << _state.min 
              //           << " [a,b,c]=[" << _state.N[ 0 ] << "," << _state.N[ 1 ] << "," << _state.N[ 2 ] << "]" 
              //           << std::endl;
              result = 2;
            }
          else
            {
              Point M = _state.ptMax - _state.ptMin;
              if ( _state.nbValid < 3 )
                newCurrentSegment( _state, M );
              else
                newCurrentTriangle( _state, M );
              computeNormal( _state );
            }
        }
      if (loop>=1000) {
        std::cerr << "[ChordNaivePlane::extend()]"
                  << " more than 1000 loops, computing error suspected" << std::endl;
        result = 1;
      }
    }
  // Goes back to starting state.
  myPointSet.erase( itP );
  return result == 2;
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
template <typename TInputIterator>
bool
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
extend( TInputIterator it, TInputIterator itE )
{
  BOOST_CONCEPT_ASSERT(( boost::InputIterator<TInputIterator> ));
  // was unable to find a correct plane.
  return false;
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
template <typename TInputIterator>
bool
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
isExtendable( TInputIterator it, TInputIterator itE ) const
{
  BOOST_CONCEPT_ASSERT(( boost::InputIterator<TInputIterator> ));
  return false;
}


//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
template <typename Vector3D>
inline
void
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
getNormal( Vector3D & normal ) const
{
  for ( Dimension i = 0; i < 3; ++i )
    normal[ i ] = NumberTraits<InternalScalar>::castToDouble( myState.N[ i ] );
}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
template <typename Vector3D>
inline
void
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
getUnitNormal( Vector3D & normal ) const
{
  getNormal( normal );
  double l = sqrt( normal[ 0 ] * normal[ 0 ]
		   + normal[ 1 ] * normal[ 1 ]
		   + normal[ 2 ] * normal[ 2 ] );
  normal[ 0 ] /= l;
  normal[ 1 ] /= l;
  normal[ 2 ] /= l;
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
inline
void
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
getBounds( double & min, double & max ) const
{
  double nx = NumberTraits<InternalScalar>::castToDouble( myState.N[ 0 ] );
  double ny = NumberTraits<InternalScalar>::castToDouble( myState.N[ 1 ] );
  double nz = NumberTraits<InternalScalar>::castToDouble( myState.N[ 2 ] );
  double l = sqrt( nx*nx + ny*ny + nz*nz );
  min = NumberTraits<InternalScalar>::castToDouble( myState.min ) / l;
  max = NumberTraits<InternalScalar>::castToDouble( myState.max ) / l;
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
inline
const typename DGtal::ChordNaivePlane<TPoint, TInternalScalar>::Point &
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
minimalPoint() const
{
  ASSERT( ! this->empty() );
  return *(myState.indMin);
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
inline
const typename DGtal::ChordNaivePlane<TPoint, TInternalScalar>::Point &
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
maximalPoint() const
{
  ASSERT( ! this->empty() );
  return *(myState.indMax);
}



///////////////////////////////////////////////////////////////////////////////
// Interface - public :
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
template <typename TVector1, typename TVector2>
inline
typename DGtal::ChordNaivePlane<TPoint, TInternalScalar>::InternalScalar
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
internalDot( const TVector1 & u, const TVector2 & v )
{
  return (InternalScalar) u[ 0 ] * (InternalScalar) v[ 0 ]
    +    (InternalScalar) u[ 1 ] * (InternalScalar) v[ 1 ]
    +    (InternalScalar) u[ 2 ] * (InternalScalar) v[ 2 ];
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
template <typename TVector1, typename TVector2>
inline
void
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
internalCross( InternalVector & n, const TVector1 & u, const TVector2 & v )
{
  n[ 0 ] = (InternalScalar) u[ 1 ] * (InternalScalar) v[ 2 ] - (InternalScalar) u[ 2 ] * (InternalScalar) v[ 1 ];
  n[ 1 ] = (InternalScalar) u[ 2 ] * (InternalScalar) v[ 0 ] - (InternalScalar) u[ 0 ] * (InternalScalar) v[ 2 ];
  n[ 2 ] = (InternalScalar) u[ 0 ] * (InternalScalar) v[ 1 ] - (InternalScalar) u[ 1 ] * (InternalScalar) v[ 0 ];
}

/**
 * Writes/Displays the object on an output stream.
 * @param out the output stream where the object is written.
 */
template <typename TPoint, typename TInternalScalar>
inline
void
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::selfDisplay ( std::ostream & out ) const
{
  selfDisplay( out, myState );
}
/**
 * Writes/Displays the object on an output stream.
 * @param out the output stream where the object is written.
 */
template <typename TPoint, typename TInternalScalar>
inline
void
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::selfDisplay ( std::ostream & out, const State & state ) const
{
  double min, max;
  double N[ 3 ];
  out << "[ChordNaivePlane"
      << " axis=" << z << " w=" << myWidth0 << "/" << myWidth1
      << " size=" << size() 
      << " N=(" << state.N[ 0 ] << "," << state.N[ 1 ] << "," << state.N[ 2 ] << ")"  
      << " A=(" << state.A[ 0 ] << "," << state.A[ 1 ] << "," << state.A[ 2 ] << ")"  
      << " B=(" << state.B[ 0 ] << "," << state.B[ 1 ] << "," << state.B[ 2 ] << ")"  
      << " C=(" << state.C[ 0 ] << "," << state.C[ 1 ] << "," << state.C[ 2 ] << ")"  
      << " #=" << state.nbValid
      << " min=" << state.min
      << " max=" << state.max
      << ": ";
  this->getUnitNormal( N );
  this->getBounds( min, max );
  out << min << " <= " 
      << N[ 0 ] << " * x + "
      << N[ 1 ] << " * y + "
      << N[ 2 ] << " * z "
      << " <= " << max << " ]"; 
}

/**
 * Checks the validity/consistency of the object.
 * @return 'true' if the object is valid, 'false' otherwise.
 */
template <typename TPoint, typename TInternalScalar>
inline
bool
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::isValid() const
{
  return z < 3;
}


///////////////////////////////////////////////////////////////////////////////
// Internals
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
void
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
setUpNormal( State & state ) const
{
  switch ( state.nbValid ) {
  case 1: setUpNormal1( state ); break;
  case 2: setUpNormal2( state ); break;
  case 3: setUpNormal3( state ); break;
  }
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
void
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
setUpNormal1( State & state ) const
{
  state.A.reset(); 
  state.B.reset(); 
  state.C.reset();
  computeNormal( state );
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
void
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
setUpNormal2( State & state ) const
{ // In this case, we create an imaginary point in the plane 0xy, orthogonal to direction AB.
  state.N[ x ] = state.N[ y ] = NumberTraits<InternalScalar>::ZERO;
  state.N[ z ] = NumberTraits<InternalScalar>::ONE;
  state.A = state.B - state.A;
  // internalCross( state.C, state.A, state.N );
  state.C[ x ] = state.A[ y ];
  state.C[ y ] = -state.A[ x ];
  state.C[ z ] = 0;
  if ( ( state.C[ x ] != 0 ) || ( state.C[ y ] != 0 ) ) // v is zero iff _state.A is aligned with main axis
    internalCross( state.N, state.C, state.A );
  state.B = -state.A - state.C;
  if ( state.N[ z ] < 0 ) {
    state.N[ 0 ] = -state.N[ 0 ];
    state.N[ 1 ] = -state.N[ 1 ];
    state.N[ 2 ] = -state.N[ 2 ];
    Point M = state.A;
    state.A = state.B;
    state.B = M;
  }
  // state.A = state.A[ z ] >= state.B[ z ] ? state.A - state.B : state.B - state.A;
  // state.B.reset(); 
  // state.C.reset();
  // computeNormal( state );
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
void
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
setUpNormal3( State & state ) const
{
  state.A = state.B - state.A; // p2 - p1;
  state.B = state.C - state.B; // p3 - p2;
  state.C = -state.A - state.B;// p1 - p3;
  computeNormal( state );
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
bool
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
setUp1( const Point & p1 )
{
  myState.nbValid = 1;
  myState.height = NumberTraits<InternalScalar>::ZERO;
  setUpNormal1( myState );
  myState.ptMax = p1;
  myState.ptMin = p1;
  myState.max = (InternalScalar) p1[ z ];
  myState.min = myState.max;
  return true;
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
int
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
signDelta( const Point & A, const Point & B, const Point & C ) const
{
  InternalScalar res = 
    ( (InternalScalar) (B[ x ]-A[ x ]) ) * ( (InternalScalar) (C[ y ]-A[ y ]) )
    - ( (InternalScalar) (B[ y ]-A[ y ]) ) * ( (InternalScalar) (C[ x ]-A[ x ]) );
  return ( res > (InternalScalar) 0 ) 
    ? 1 : ( ( res < (InternalScalar) 0 ) ? -1 : 0 );
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
int
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
signDelta( const Point & A, const Point & C ) const
{ // B is zero
  InternalScalar res = 
    ( (InternalScalar) (-A[ x ]) ) * ( (InternalScalar) (C[ y ]-A[ y ]) )
    - ( (InternalScalar) (-A[ y ]) ) * ( (InternalScalar) (C[ x ]-A[ x ]) );
  return ( res > (InternalScalar) 0 ) 
    ? 1 : ( ( res < (InternalScalar) 0 ) ? -1 : 0 );
}

//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
template <typename TInputIterator>
bool
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
updateMinMax( State & state, TInputIterator itB, TInputIterator itE ) const
{
  BOOST_CONCEPT_ASSERT(( boost::InputIterator<TInputIterator> ));
  bool changed = false;
  for ( ; itB != itE; ++itB )
    {
      InternalScalar s = internalDot( state.N, *itB );
      if ( s > state.max ) {
        state.max = s; 
        state.ptMax = *itB;
        changed = true;
      } else if ( s < state.min ) {
        state.min = s; 
        state.ptMin = *itB;
        changed = true;
      }
    }
  return changed;
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
template <typename TInputIterator>
void
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
computeMinMax( State & state, TInputIterator itB, TInputIterator itE ) const
{
  BOOST_CONCEPT_ASSERT(( boost::InputIterator<TInputIterator> ));
  ASSERT( itB != itE );
  InternalScalar s = internalDot( state.N, *itB );
  state.min = state.max = s;
  state.ptMin = state.ptMax = *itB;
  ++itB;
  for ( ; itB != itE; ++itB )
    {
      s = internalDot( state.N, *itB );
      if ( s > state.max ) {
        state.max = s; 
        state.ptMax = *itB;
      } else if ( s < state.min ) {
        state.min = s; 
        state.ptMin = *itB;
      }
    }
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
template <typename TInputIterator>
unsigned int
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
findTriangle( State & state, TInputIterator itB, TInputIterator itE ) const
{
  BOOST_CONCEPT_ASSERT(( boost::InputIterator<TInputIterator> ));
  if ( itB == itE ) return 0;
  state.A = *itB++; // first point
  for ( ; ( itB != itE ) && alignedAlongAxis( state.A, *itB ); ++itB )
    ;
  if ( itB == itE ) return 1; 
  state.B = *itB++; // second point
  for ( ; ( itB != itE ) && ( signDelta( state.A, state.B, *itB ) == 0 ); ++itB )
    ;
  if ( itB == itE ) return 2; 
  state.C = *itB;   // third point
  return 3;
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
bool
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
alignedAlongAxis( const Point & p1, const Point & p2 ) const
{
 return ( p1[ x ] == p2[ x ] ) && ( p1[ y ] == p2[ y ] );
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
void
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
computeHeight( State & state ) const
{
  state.height = internalDot( state.A, state.N );
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
void
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
computeNormal( State & state ) const
{
  InternalVector v;
  switch ( state.nbValid ) {
  case 1:
      state.N[ x ] = state.N[ y ] = NumberTraits<InternalScalar>::ZERO;
      state.N[ z ] = NumberTraits<InternalScalar>::ONE;
      break;
  case 2:
    // std::cerr << "Should not go there..." << std::endl;
    //   state.N[ x ] = state.N[ y ] = NumberTraits<InternalScalar>::ZERO;
    //   state.N[ z ] = NumberTraits<InternalScalar>::ONE;
    //   internalCross( v, state.N, state.A );
    //   if ( ( v[ 0 ] != 0 ) || ( v[ 1 ] != 0 ) || ( v[ 2 ] != 0 ) ) // v is zero iff _state.A is aligned with main axis
    //     internalCross( state.N, state.A, v );
    //   break;
  default: // 3
    internalCross( state.N, state.B - state.A, state.C - state.A );
    if ( state.N[ z ] < 0 ) {
      state.N[ 0 ] = -state.N[ 0 ];
      state.N[ 1 ] = -state.N[ 1 ];
      state.N[ 2 ] = -state.N[ 2 ];
      Point M = state.A;
      state.A = state.B;
      state.B = M;
    }
  }
  // std::cout << "computeNormal: #=" << state.nbValid
  //           << " A=" << state.A 
  //           << " B=" << state.B
  //           << " C=" << state.C
  //           << " N=[" << state.N[ 0 ]
  //           << "," << state.N[ 1 ]
  //           << "," << state.N[ 2 ]
  //           << "]" << std::endl;
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
bool
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
checkWidth( const State & state ) const
{
  // return ( ( state.max - state.min ) * myWidth1 )
  //   <= ( state.height * myWidth0 );
  return ( state.max - state.min ) <= state.height;
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
bool
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
newCurrentTriangle( State & state, const Point & M ) const
{
  int da =  signDelta( state.A, M ); // A, O, M
  int db =  signDelta( state.B, M ); // B, O, M
  int dc =  signDelta( state.C, M ); // C, O, M
  if ( ( da >= 0 ) && ( db <= 0 ) ) {
    if ( ( signDelta( state.A, state.B ) == 0 ) && ( da == 0 ) ) {
      if ( ( state.A[ x ] * M[ x ] > 0 ) || ( state.A[ y ] * M[ y ] > 0 ) )
        state.A = M;
      else
        state.B = M;
    } else 
      state.C = M;
  } else if ( ( db >= 0 ) && ( dc <= 0 ) ) {
    if ( ( signDelta( state.B, state.C ) ==0 ) && ( db == 0 ) ) {
      if ( ( state.B[ x ] * M[ x ] > 0 ) || ( state.B[ y ] * M[ y ] > 0 ) ) 
        state.B = M;
      else
        state.C = M;
    } else
      state.A = M;
  } else if ( ( dc >= 0 ) && ( da <= 0 ) ) {
    if ( ( signDelta( state.C, state.A ) ==0 ) && ( dc == 0 ) ) {
      if ( ( state.C[ x ] * M[ x ] > 0 ) || ( state.C[ y ] * M[ y ] > 0 ) ) 
        state.C = M;
      else
        state.A = M;
    } else
      state.B = M;
  } else {
    std::cerr << "[ChordNaivePlane::newCurrentTriangle]"
              << " cannot find a triangle cutting the main axis" << std::endl;
    return false;
  }
  return true;
}
//-----------------------------------------------------------------------------
template <typename TPoint, typename TInternalScalar>
bool
DGtal::ChordNaivePlane<TPoint, TInternalScalar>::
newCurrentSegment( State & state, const Point & M ) const
{
  if ( internalDot( state.A, state.N ) < internalDot( M, state.N ) )
    state.A = M; // either M or M - state.A may induce infinite loops.
  else
    {    
      std::cerr << "[ChordNaivePlane::newCurrentSegment]"
                << " cannot find a segment cutting the main axis" << std::endl;
      return false;
    }
  return true;
}

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

template <typename TPoint, typename TInternalScalar>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
                    const ChordNaivePlane<TPoint, TInternalScalar> & object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


